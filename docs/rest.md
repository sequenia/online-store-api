# REST

## Общие положения

[REST](https://ru.wikipedia.org/wiki/REST) архитектура клиент-серверного взаимодействия не диктует четких правил по:
- Построению URL-ов
- Разбиению URL-ов на группы
- Использованию тех или иных типов запросов (GET, POST и т.д.)
- Форматам данных, передаваемых в запросы и возвращаемых запросами

Ниже приведен свод правил для того, чтобы структурировать API-запросы серверного приложения.

## Структура URL

Для того, чтобы было удобно ориентироваться во всём множестве API-запросов, необходимо зафиксировать четкую структуру URL-ов.

Большинство API-запросов в интернет-магазине являются способом взаимодействия с теми или иными сущностями, которые так или иначе хранятся в базе данных на сервере. Следовательно, будет удобно группировать API-запросы по сущностям, начиная путь URL-а с имени сущности.

Если для клиентской стороны сущность существует во множественном числе, то её имя в запросе должно быть во множественном числе. Иначе - в единственном. Например, товары существуют во множественном числе, значит путь будет начинаться со слова `products`. Текущий пользователь существует в единственном числе, значит путь будет начинаться со словосочетания `current_user`. То же самое и для корзины - она существует в единственном числе, значит путь будет начинаться с `cart`.

Типов взаимодействия не может быть слишком много, и вот основные из них:
- Получить список объектов
- Получить детальную информацию об объекте
- Создать объект
- Обновить объект
- Удалить объект
- Получить значения по умолчанию для создания объекта

Каждому из этих типов взаимодействия можно назначить структуру пути и тип HTTP-запроса, подходящий по смыслу.

Учитывая описанное выше, предлагается следующая структура API запросов. Для сущностей в множественном числе:

|Тип       |Путь          |Описание                                           |
|----------|--------------|---------------------------------------------------|
|GET       |/:entities    |Получить список объектов                           |
|GET       |/:entities/:id|Получить объект по идентификатору                  |
|POST      |/:entities    |Создать объект                                     |
|PATCH\|PUT|/:entities/:id|Обновить объект с идентификатором                  |
|DELETE    |/:entities/:id|Удалить объект по идентификатору                   |
|GET       |/:entities/new|Получить значения по умолчанию для создания объекта|

Для сущностей в единственном числе:

|Тип       |Путь          |Описание                  |
|----------|--------------|--------------------------|
|GET       |/:entity      |Получить объект           |
|PATCH\|PUT|/:entity      |Обновить объект           |

## Отделение API от сайта

### Задача

Чтобы не путаться между запросами веб-страниц и API-запросами, стоит ввести явное разделение на уровне URL-ов.

Есть несколько способов, со своими плюсами и минусами.

### Способ 1. Префикс

Путям всех API запросов можно выдать значимый префикс, например `/api`. Тогда пути всех запросов примут вид `/api/some/path`. Такой подход не требует тонкой настройки веб-сервера, а так же все API-запросы могут находиться на том же самом домене, что и сайт. Однако, префикс будет дублироваться во всех API-запросах.

Способ является предпочтительным в том случае, если сайт и API реализованы монорепозиторием в одном проекте.

### Способ 2. Домен

API может быть развернуто на специальном домене, отличном от основного домена сайта. Такой способ не внесет в URL-ы дублирующейся информации, но более сложен, чем первый. Он требует:
- Дополнительного домена
- Тонкой настройки веб-сервера (nginx, apache и т.д)
- Разделения сайта и API на отдельные проекты или дополнительной настройки веб-сервера, так как в рамках одного проекта в исходном коде всё равно придется вносить разделение между запросами веб-страниц и API-запросами.

Способ является предпочтительным, если вы планируете создавать сайт и API отдельными проектами, в которых запросы веб-страниц и API-запросы не будут пересекатся.

## Версии API

С развитием сервиса может потребоваться реализовать новую версию API. Чтобы было удобно работать с разными версиями API стоит заранее завести возможность передавать соответствующую информацию в запросы.

Есть много способов, которые имеют свои собственные плюсы и минусы:
- Указывать версию API в пути запроса, например `/api/:version/some/path`.
- Передавать версию API в заголовках запроса.
- и т.д.

Выбирайте тот способ, который вам проще всего реализовать, и который будет удобен для использования клиентам вашего API.

## Единый формат ответа

Для всех API-запросов следует завести единый формат ответа, чтобы клиент мог написать единый обработчик для всех запросов. Это особенно актуально для тех клиентов, которые реализованы на статически-типизируемых языках программирования, например Android-приложения на Kotlin и iOS-приложения на Swift.

Зафиксируйте верхнеуровневый набор полей в ответе от сервера и типы их данных. В рамках ответа на каждый конкретный запрос зафиксируйте тип данных каждого из полей.

Не должно быть подобных случаев:
- При наличии данных в поле выдается массив, а при отсутствии данных в том же поле - пустая строка.
- При наличии данных в поле выдается объект, а при отсутствии данных в том же поле - пустой массив.
- и т.д.

API должно всегда возвращать валидный JSON. Хоть в случае успеха, хоть в случае ошибки. Любой ошибки, даже необработанного исключения. Не должно быть ситуации, что при коде ответа 500 API вернуло HTML-страницу.

Пример единого формата ответа:

```json
{
  "success": true,
  "data": {},
  "errorCode": "",
  "errorMessage": "",
  "errors": {}
}
```

В данном примере приведены следующие поля:
- `success` - `Boolean`. Индикатор успешности выполнения запроса. Если запрос выполнить удалось, имеет значение `true`. Если не удалось - `false`.
- `data` - `Object`. Если запрос выполнился успешно, в данном поле находится объект с информацией, которую запрашивает клиент. Если запрос выполнился неуспешно - имеет значение `null`. 
- `errorCode` - `String`. Если запрос выполнился успешно, содержит значение `null`. Если запрос выполнился неуспешно, содержит код произошедшей ошибки. Это не HTTP-статус, а индикатор конкретной ошибки конкретного запроса. Например, если при аутентификации не удалось найти учетную запись, то кодом ошибки может быть `profile_not_found`.
- `errorMessage` - `String`. Если запрос выполнился успешно, содержит значение `null`. Если запрос выполнился неуспешно, содержит локализованное сообщение для пользователя. В нём не должно быть информации для отладки.
- `errors` - `Object`. Если запрос выполнился успешно, содержит значение `null`. Если запрос выполнился неупешно, может содержать объект с детальной информацией об ошибках. Используется в запросах на создание/редактирование, чтобы сообщить на клиент информацию об ошибках в каждом поле, переданном в запрос.

## Информация об ошибках при создании и обновлении

В запросы на создание и обновление могут передаваться данные с любым уровнем вложенности. Вложенности могут представлять из себя как объекты, так и массивы. Например, запрос обновления информации о профиле может принимать такой JSON:

```json
{
  "profile": {
    "fistName": "Гарри",
    "lastName": "Поттер",
    "address": {
      "country": "Великобритания",
      "city": "Литтл Уингинг",
      "street": "Тисовая улица",
      "house": "4",
      "comments": "Чулан под лестницей"
    },
    "relatives": [
      {
        "firstName": "Джеймс",
        "lastName": "Поттер",
        "role": "father"
      },
      {
        "firstName": "Лили",
        "lastName": "Поттер",
        "role": "mother"
      }
    ]
  }
}
```

В каждом поле на каждом уровне вложенности могут произойти ошибки, о которых нужно сообщить на клиент. С каждым полем может произойти сразу несколько ошибок, например, "Слишком длинное" и "Имеет недопустимые символы". Если того требует дизайн, клиент должен иметь возможность отобразить ошибку около того самого поля, с которым ошибка произошла.

Учитывая описанное выше, можно составить следующую рекурсивную структуру ошибок:

```java
public class ObjectErrors {
  private Map<String, List<String>> fields;
  private Map<String, ObjectErrors> objects;
  private Map<String, List<ArrayObjectErrors>> arrays;
}

public class ArrayObjectErrors extends ObjectErrors {
  private int index;
}
```

Описание полей `ObjectErrors`:

- В `fields` содержатся ошибки по каждому из полей в объекте. Ключ - имя поля. Значение - список ошибок.
- В `objects` содержится информация об ошибках полей во вложенных объектах. Ключ - имя объекта. Значение - информация об ошибках в его полях.
- В `arrays` содержится информация об ошибках полей во вложенных массивах. Ключ - имя массива. Значение - информация об ошибках в его объектах.

Описание полей `ArrayObjectErrors`, наследника от `ObjectErrors`:
- `index` - индекс объекта из переданных параметров. Необходим, чтобы клиент смог определить, с каким именно объектом из массива произошла ошибка.

Для приведенного выше примера ответ с ошибками может выглядеть так:

```json
{
  "success": false,
  "data": null,
  "errorCode": "not_valid",
  "errorMessage": "Переданы некорректные значения",
  "errors": {
    "fields": {
      "firstName": ["Слишком длинное", "Имеет недопустимые символы"],
      "relatives": ["Указано слишком много родителей, максимум 2"]
    },
    "objects": {
      "address": {
        "fields": {
          "country": ["Такой страны не существует"],
          "comments": ["Слишком длинное"]
        },
        "objects": {},
        "arrays": {}
      }
    },
    "arrays": {
      "relatives": [
        {
          "index": 1,
          "fields": {
            "firstName": ["Имеет недопустимые символы"],
            "role": ["Не существует"]
          },
          "objects": {},
          "arrays": {}
        }
      ]
    }
  }
}
```

Обратите внимание, что у вложенного массива ошибка может случиться как по всему массиву в целом (например, слишком много элементов), так и по конкретным объектам в частности. Поэтому упоминание массива может встретиться как в `fields`, так и в `arrays`. То же самое и с объектами. По этой причине введено явное разделение полей объекта на атомарные и структурные.

## Коды ответа HTTP

Составьте соответствие кодов ответа HTTP с результатами выполнения запросов.

При успешном выполнении запроса он должен возвращать такой код ответа HTTP, который соответствует успеху. Например, всегда возвращать 200 при успехе.

Составьте соответствие ошибок запросов с кодами ответа HTTP, которые подходят по смыслу к конкретной ошибке. Вот самые популярные из них, которых обычно хватает при создании REST API:

- 400 (Bad Request) - Сервер не понял формат переданных данных. Например, вместо JSON-а был отправлен XML или невалидный JSON.
- 401 (Unauthorized) - Запрос требует авторизации, но не было передано никаких авторизационных данных или по авторизационным данным не удалось идентифицировать клиент.
- 403 (Forbidden) - Удалось идентифицировать клиент, но у него нет прав на выполнение запроса.
- 404 (Not Found) - Не удалось найти запрашиваемые данные. Например, объект с переданным id отсутствует в базе данных.
- 422 (Unprocessable Entity) - Сервер понял тип содержимого, но ему не удалось корректно обработать данные. Например, если клиент передал в поле объекта недопустимые символы.

## Минимум логики на клиенте

Всю логику, которую можно вынести на сервер, нужно выносить на сервер и не заставлять разработчиков клиентов самостоятельно её реализовывать. Клиентское приложение должно быть лишь отображением и сборщиком информации, а не концентрацией логики.

Сервер один, а клиентов много. Если каждый клиент самостоятельно реализовывает логику, это когда-нибудь неизбежно приведет к логическим отличиям между клиентами. Если логика сконцентрирована на сервере, то можно свести к минимуму количество логических отличий между клиентами.

В каждом из клиентов могут найтись баги, и для их устранения придется перевыпускать клиент, что не всегда можно сделать оперативно. Например, процесс публикации обновлений мобильных приложений на платформах Android и iOS может занимать до нескольких дней, а затем последует ещё долгое обновление приложения на всех устройствах. Устранить баг на сервере гораздо проще.

Пример. В мобильном приложении или на сайте пользователь должен выбрать город проживания, от которого будет зависеть товарная выдача в каталоге. Задачу можно решить несколькими способами:

1. Сохранить выбранный город на клиенте и передавать его во все остальные запросы, в которых выдача может зависеть от выбранного города.
2. Передать выбранный город на сервер, сохранить его в базе данных в профиле пользователя и использовать в тех запросах, в которых необходимо.

Второй способ предпочтительнее, так как позволяет:

1. Не добавлять в запросы лишние параметры.
2. Не усложнять программный код сразу нескольких клиентов.
3. Не дорабатывать клиент, если информация о городе пользователя понадобилась в тех запросах, в которых раньше не участвовала.

## Чем меньше совершается API-запросов, тем лучше

Выполнение любого API-запроса может завершиться с ошибкой. Чем больше API-запросов должен выполить клиент, тем больше потенциальных ошибок может произойти. Качественное приложение должно информировать пользователя о случившихся ошибках. А чем больше ошибок может произойти, тем больше кода для их обработки нужно написать. Следовательно, для повышения стабильности работы клиентского приложения, стоит минимизирровать количество вызовов API-запросов.

Пример 1. На главном экране сайта или приложения необходимо показать ограниченный список из разных блоков. По дизайну первым блоком всегда отображается баннер во всю ширину экрана, а далее могут чередоваться баннеры с отступами от экрана по бокам и горизонтальные слайдеры с подборками товаров. Вместо множества отдельных API-запросов на получение информации о каждом блоке создайте единый API-запрос, который выдаст всю необходимую информацию о блоках в виде списка. Иначе у клиента будет 2 варианта решения задачи:

1. Показать единый индикатор загрузки, выполнить множество API-запросов, скрыть индикатор загрузки. В таком случае разбиение на несколько API-запросов вообще не имеет никакого смысла и только усложняет клиент. У разработчиков появится множество вопросов вида - а что делать, если второй из четырёх API-запросов совершился с ошибкой?

2. Для каждого блока показать свой собственный индикатор загрузки, запускать API-запросы и отображать ошибки для каждого блока в отдельности. В таком случае логических несостыковок будет минимум, но на программирование такой логики можно потратить уйму времени, что в итоге не принесет большой пользы по сравнению с единым индикатором загрузки для всего экрана. Делать так стоит только в том случае, если позволяет бюджет.

// TODO схематично показать вид экрана.

Пример 2. На экране корзины нужно предоставить возможность очистить корзину нажатием на соответствующую кнопку. Ранее уже был реализован функционал удаления конкретного товара из корзины. Если решать задачу без доработки API, то клиентское приложение для очистки корзины должно будет вызвать запрос на удаление каждого товара в корзине, а их может быть много. Если реализовать дополнительный запрос для удаления сразу всех товаров из корзины, можно упростить программирование клиента и сделать его работу стабильнее.

## Универсальность - если можно сделать одинаково, делать одинаково. Например - подборка товаров, это просто фильтрация.

// TODO

## Однакоковые названия одинаковых полей у одинаковых объектов в разных запросах.

// TODO
