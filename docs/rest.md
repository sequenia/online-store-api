# REST

## Общие положения

[REST](https://ru.wikipedia.org/wiki/REST) архитектура клиент-серверного взаимодействия не диктует четких правил по:
- Построению URL-ов
- Разбиению URL-ов на группы
- Использованию тех или иных типов запросов (GET, POST и т.д.)
- Форматам данных, передаваемых в запросы и возвращаемых запросами

Ниже приведен свод правил для того, чтобы структурировать API-запросы серверного приложения.

## Структура URL

Для того, чтобы было удобно ориентироваться во всём множестве API-запросов, необходимо зафиксировать четкую структуру URL-ов.

Большинство API-запросов в интернет-магазине являются способом взаимодействия с теми или иными сущностями, которые так или иначе хранятся в базе данных на сервере. Следовательно, будет удобно группировать API-запросы по сущностям, начиная путь URL-а с имени сущности.

Если для клиентской стороны сущность существует во множественном числе, то её имя в запросе должно быть во множественном числе. Иначе - в единственном. Например, товары существуют во множественном числе, значит путь будет начинаться со слова `products`. Текущий пользователь существует в единственном числе, значит путь будет начинаться со словосочетания `current_user`. То же самое и для корзины - она существует в единственном числе, значит путь будет начинаться с `cart`.

Типов взаимодействия не может быть слишком много, и вот основные из них:
- Получить список объектов
- Получить детальную информацию об объекте
- Создать объект
- Обновить объект
- Удалить объект
- Получить значения по умолчанию для создания объекта

Каждому из этих типов взаимодействия можно назначить структуру пути и тип HTTP-запроса, подходящий по смыслу.

Учитывая описанное выше, предлагается следующая структура API запросов. Для сущностей в множественном числе:

|Тип       |Путь          |Описание                                           |
|----------|--------------|---------------------------------------------------|
|GET       |/:entities    |Получить список объектов                           |
|GET       |/:entities/:id|Получить объект по идентификатору                  |
|POST      |/:entities    |Создать объект                                     |
|PATCH\|PUT|/:entities/:id|Обновить объект с идентификатором                  |
|DELETE    |/:entities/:id|Удалить объект по идентификатору                   |
|GET       |/:entities/new|Получить значения по умолчанию для создания объекта|

Для сущностей в единственном числе:

|Тип       |Путь          |Описание                  |
|----------|--------------|--------------------------|
|GET       |/:entity      |Получить объект           |
|PATCH\|PUT|/:entity      |Обновить объект           |

## Отделение API от сайта

### Задача

Чтобы не путаться между запросами веб-страниц и API-запросами, стоит ввести явное разделение на уровне URL-ов.

Есть несколько способов, со своими плюсами и минусами.

### Способ 1. Префикс

Путям всех API запросов можно выдать значимый префикс, например `/api`. Тогда пути всех запросов примут вид `/api/some/path`. Такой подход не требует тонкой настройки веб-сервера, а так же все API-запросы могут находиться на том же самом домене, что и сайт. Однако, префикс будет дублироваться во всех API-запросах.

Способ является предпочтительным в том случае, если сайт и API реализованы монорепозиторием в одном проекте.

### Способ 2. Домен

API может быть развернуто на специальном домене, отличном от основного домена сайта. Такой способ не внесет в URL-ы дублирующейся информации, но более сложен, чем первый. Он требует:
- Дополнительного домена
- Тонкой настройки веб-сервера (nginx, apache и т.д)
- Разделения сайта и API на отдельные проекты или дополнительной настройки веб-сервера, так как в рамках одного проекта в исходном коде всё равно придется вносить разделение между запросами веб-страниц и API-запросами.

Способ является предпочтительным, если вы планируете создавать сайт и API отдельными проектами, в которых запросы веб-страниц и API-запросы не будут пересекатся.

## Версии API

С развитием сервиса может потребоваться реализовать новую версию API. Чтобы было удобно работать с разными версиями API стоит заранее завести возможность передавать соответствующую информацию в запросы.

Есть много способов, которые имеют свои собственные плюсы и минусы:
- Указывать версию API в пути запроса, например `/api/:version/some/path`.
- Передавать версию API в заголовках запроса.
- и т.д.

Выбирайте тот способ, который вам проще всего реализовать, и который будет удобен для использования клиентам вашего API.

## Коды ответа HTTP

Составьте соответствие кодов ответа HTTP с результатами выполнения запросов.

При успешном выполнении запроса он должен возвращать такой код ответа HTTP, который соответствует успеху, то есть от 200 до 299.

Составьте соответствие ошибок запросов с кодами ответа HTTP, которые подходят по смыслу к конкретной ошибке. Вот самые популярные из них, которых обычно хватает при создании REST API:

- 400 (Bad Request) - Сервер не понял формат переданных данных. Например, вместо JSON-а был отправлен XML или невалидный JSON.
- 401 (Unauthorized) - Запрос требует авторизации, но не было передано никаких авторизационных данных или по авторизационным данным не удалось идентифицировать клиент.
- 403 (Forbidden) - Удалось идентифицировать клиент, но у него нет прав на выполнение запроса.
- 404 (Not Found) - Не удалось найти запрашиваемые данные. Например, объект с переданным id отсутствует в базе данных.
- 422 (Unprocessable Entity) - Сервер понял тип содержимого, но ему не удалось корректно обработать данные. Например, если клиент передал в поле объекта недопустимые символы.

## Формат ответа от сервера

API должно всегда возвращать валидный JSON. Хоть в случае успеха, хоть в случае ошибки. Любой ошибки, даже необработанного исключения. Не должно быть ситуации, что при коде ответа 500 API вернуло HTML-страницу.

В рамках ответа на каждый конкретный запрос зафиксируйте тип данных каждого из полей. Не должно быть подобных случаев:
- При наличии данных в поле выдается массив, а при отсутствии данных в том же поле - пустая строка.
- При наличии данных в поле выдается объект, а при отсутствии данных в том же поле - пустой массив.
- и т.д.

Тело успешного ответа всегда должно быть объектом, в полях которого возвращается запрашиваемая информация. Например, если запрос возвращает пользователя, то ответом должен быть объект с полем `user`. Если запрос возвращает список товаров, то ответом должен быть объект с полем `products`. Таким образом, если в будущем нужно будет обогатить ответ дополнительными данными, то не придется перерабатывать структуру ответа, нужно будет лишь добавить в него новые ключи. Примеры успешных ответов:

```json
{
  "user": {}
}
```

```json
{
  "products": []
}
```

Зафиксируйте единый формат ответа с ошибкой, в котором обязательно должны быть:
1. Сообщение, которое можно отобразить на клиенте для пользователя, объясняющее произошедшую ошибку.
2. Код ошибки для её идентификации клиентом. Это не HTTP-статус, а специальный код, сигнализирующий о конкретной ситуации при обработке запроса.

Если требуется выдать в API детальную информацию об ошибке, то зафиксируйте единый формат детальной информации и выдавайте её в соответствующем поле. 

Пример формата для ответа с ошибкой:

```json
{
  "message": "",
  "code": "",
  "errors": {}
}
```

## Формат детальной информации об ошибках

В запросы на создание и обновление могут передаваться данные с любым уровнем вложенности. Вложенности могут представлять из себя как объекты, так и массивы. Например, запрос обновления информации о профиле может принимать такой JSON:

```json
{
  "profile": {
    "fist_mame": "Гарри",
    "last_name": "Поттер",
    "address": {
      "country": "Великобритания",
      "city": "Литтл Уингинг",
      "street": "Тисовая улица",
      "house": "4",
      "comments": "Чулан под лестницей"
    },
    "relatives": [
      {
        "first_name": "Джеймс",
        "last_name": "Поттер",
        "role": "father"
      },
      {
        "first_name": "Лили",
        "last_name": "Поттер",
        "role": "mother"
      }
    ]
  }
}
```

В каждом поле на каждом уровне вложенности могут произойти ошибки, о которых нужно сообщить на клиент. С каждым полем может произойти сразу несколько ошибок, например, "Слишком длинное" и "Имеет недопустимые символы". Если того требует дизайн, клиент должен иметь возможность отобразить ошибку около того самого поля, с которым ошибка произошла.

Учитывая описанное выше, можно составить следующий формат **Детальной информации об ошибках**:

```json
{
  "entity_name": {
    "fields": {
      "field_name": [""]
    },
    "nested_object": {
      "fields": {
        "nested_object_field_name": [""]
      }
    },
    "nested_array": [
      {
        "index": 1,
        "fields": {
          "nested_array_object_field_name": [""]
        }
      }
    ]
  }
}
```

Описание полей:
  - `entity_name` - Объект, при отправке которого произошла ошибка. Имя совпадает с именем объекта, отправленного в теле запроса. Например, если в запрос был передан объект `profile`, то `entity_name` будет также равно `profile`
    - `fields` - `Object`. Содержит информацию об ошибках в тех полях, которые являются примитивами (строки, числа), а так же ошибки о вложенных объектах и массивах. **Ключ** - имя поля. **Значение** - массив ошибок.
    - `nested_object` - `Object`. Содержит информацию об ошибках в полях вложенного объекта. **Ключ** - имя вложенного объекта. **Значение** - объект с **Детальной информацией об ошибках** во вложенном объекте.
    - `nested_array` - `Object`. Содержит информацию об ошибках в полях вложенных массивов. **Ключ** - имя вложенного массива. **Значение** - массив с объектами, каждый из которых - это **Детальная информация об ошибках**, дополненная индексом объекта в массиве из тела запроса.

Примеры ошибочных ответов от сервера с **Детальной информацией об ошибках**.

```json
{
  "message": "Данные профиля пользователя не обновлены",
  "code": "profile_not_updated",
  "errors": {
    "profile": {
      "fields": {
        "first_name": ["Слишком длинное", "Имеет недопустимые символы"],
        "relatives": ["Указано слишком много родителей, максимум 2"]
      },
      "address": {
        "fields": {
          "country": ["Такой страны не существует"],
          "comments": ["Слишком длинное"]
        }
      },
      "relatives": [
        {
          "index": 1,
          "fields": {
            "first_name": ["Имеет недопустимые символы"],
            "role": ["Не существует"]
          }
        }
      ]
    }
  }
}
```

Со временем могут появиться задачи, для которых будет не достаточно знать только текст ошибки в поле. Например, по дизайну разные ошибки нужно будет показывать в разном виде. В таком случае вместо строки ошибку можно возвращать объектом, в котором есть тип и текст:

```json
{
  "message": "Переданы некорректные значения",
  "code": "not_valid",
  "errors": {
    "profile": {
      "fields": {
        "first_name": [
          {
            "type": "blank",
            "text": "Не может быть пустым"
          }
        ]
      }
    }
  }
}
```

## Минимум логики на клиенте

Всю логику, которую можно вынести на сервер, нужно выносить на сервер и не заставлять разработчиков клиентов самостоятельно её реализовывать. Клиентское приложение должно быть лишь отображением и сборщиком информации, а не концентрацией логики.

Сервер один, а клиентов много. Если каждый клиент самостоятельно реализовывает логику, это когда-нибудь неизбежно приведет к логическим отличиям между клиентами. Если логика сконцентрирована на сервере, то можно свести к минимуму количество логических отличий между клиентами.

В каждом из клиентов могут найтись баги, и для их устранения придется перевыпускать клиент, что не всегда можно сделать оперативно. Например, процесс публикации обновлений мобильных приложений на платформах Android и iOS может занимать до нескольких дней, а затем последует ещё долгое обновление приложения на всех устройствах. Устранить баг на сервере гораздо проще.

Пример. В мобильном приложении или на сайте пользователь должен выбрать город проживания, от которого будет зависеть товарная выдача в каталоге. Задачу можно решить несколькими способами:

1. Сохранить выбранный город на клиенте и передавать его во все API-запросы, в которых выдача может зависеть от выбранного города.
2. Передать выбранный город на сервер единожды, сохранить его в базе данных в профиле пользователя. Сервер при обработке любого API-запроса сможет получить город пользователя из базы данных.

Второй способ предпочтительнее, так как позволяет:

1. Не добавлять в запросы лишние параметры.
2. Не усложнять программный код сразу нескольких клиентов.
3. Не дорабатывать клиент, если информация о городе пользователя понадобилась в тех запросах, в которых раньше не участвовала.

## Чем меньше совершается API-запросов, тем лучше

Выполнение любого API-запроса может завершиться с ошибкой. Чем больше API-запросов должен выполить клиент, тем больше потенциальных ошибок может произойти. Качественное приложение должно информировать пользователя о случившихся ошибках. А чем больше ошибок может произойти, тем больше кода для их обработки нужно написать. Следовательно, для повышения стабильности работы клиентского приложения, стоит минимизирровать количество вызовов API-запросов.

Пример 1. На главном экране сайта или приложения необходимо показать ограниченный список из разных блоков. По дизайну первым блоком всегда отображается баннер во всю ширину экрана, а далее могут чередоваться баннеры с отступами от экрана по бокам и горизонтальные слайдеры с подборками товаров.

<img src="../assets/main_screen_blocks.jpg" width="500px">

Вместо множества отдельных API-запросов на получение информации о каждом блоке создайте единый API-запрос, который выдаст всю необходимую информацию о блоках в виде списка. Иначе у клиента будет 2 варианта решения задачи:

1. Показать единый индикатор загрузки, выполнить множество API-запросов, скрыть индикатор загрузки. В таком случае разбиение на несколько API-запросов вообще не имеет никакого смысла и только усложняет клиент. У разработчиков появится множество вопросов вида - а что делать, если второй из четырёх API-запросов совершился с ошибкой?

2. Для каждого блока показать свой собственный индикатор загрузки, запускать API-запросы и отображать ошибки для каждого блока в отдельности. В таком случае логических несостыковок будет минимум, но на программирование такой логики можно потратить уйму времени, что в итоге не принесет большой пользы по сравнению с единым индикатором загрузки для всего экрана. Делать так стоит только в том случае, если позволяет бюджет.

Пример 2. На экране корзины нужно предоставить возможность очистить корзину нажатием на соответствующую кнопку. Ранее уже был реализован функционал удаления конкретного товара из корзины. Если решать задачу без доработки API, то клиентское приложение должно будет для очистки корзины вызвать API-запрос на удаление каждого товара в корзине, а их может быть много. Если реализовать дополнительный запрос для удаления сразу всех товаров из корзины, можно упростить программирование клиента и сделать его работу стабильнее.

## Единая структура объектов

Структура одних и тех же объектов в ответах разных API-запросов должна быть одинаковой. Видимость полей может отличаться, но необходимо соблюдать строгость именования.

Не должно быть случаев, что запрос информации о пользователе выдает имя пользователя в поле `name`, а в списке пользователей эта же информация выдаётся в поле `first_name`.
