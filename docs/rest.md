# REST

## Общие положения

[REST](https://ru.wikipedia.org/wiki/REST) архитектура клиент-серверного взаимодействия не диктует четких правил по:
- Построению URL-ов
- Разбиению URL-ов на группы
- Использованию тех или иных типов запросов (GET, POST и т.д.)
- Форматам данных, передаваемых в запросы и возвращаемых запросами

Ниже приведен свод правил для того, чтобы структурировать API-запросы серверного приложения.

## Структура URL

Для того, чтобы было удобно ориентироваться во всём множестве API-запросов, необходимо зафиксировать четкую структуру URL-ов.

Большинство API-запросов в интернет-магазине являются способом взаимодействия с теми или иными сущностями, которые так или иначе хранятся в базе данных на сервере. Следовательно, будет удобно группировать API-запросы по сущностям, начиная путь URL-а с имени сущности.

Если для клиентской стороны сущность существует во множественном числе, то её имя в запросе должно быть во множественном числе. Иначе - в единственном. Например, товары существуют во множественном числе, значит путь будет начинаться со слова `products`. Текущий пользователь существует в единственном числе, значит путь будет начинаться со словосочетания `current_user`. То же самое и для корзины - она существует в единственном числе, значит путь будет начинаться с `cart`.

Типов взаимодействия не может быть слишком много, и вот основные из них:
- Получить список объектов
- Получить детальную информацию об объекте
- Создать объект
- Обновить объект
- Удалить объект
- Получить значения по умолчанию для создания объекта

Каждому из этих типов взаимодействия можно назначить структуру пути и тип HTTP-запроса, подходящий по смыслу.

Учитывая описанное выше, предлагается следующая структура API запросов. Для сущностей в множественном числе:

|Тип       |Путь          |Описание                                           |
|----------|--------------|---------------------------------------------------|
|GET       |/:entities    |Получить список объектов                           |
|GET       |/:entities/:id|Получить объект по идентификатору                  |
|POST      |/:entities    |Создать объект                                     |
|PATCH\|PUT|/:entities/:id|Обновить объект с идентификатором                  |
|DELETE    |/:entities/:id|Удалить объект по идентификатору                   |
|GET       |/:entities/new|Получить значения по умолчанию для создания объекта|

Для сущностей в единственном числе:

|Тип       |Путь          |Описание                  |
|----------|--------------|--------------------------|
|GET       |/:entity      |Получить объект           |
|PATCH\|PUT|/:entity      |Обновить объект           |

## Отделение API от сайта

### Задача

Чтобы не путаться между запросами веб-страниц и API-запросами, стоит ввести явное разделение на уровне URL-ов.

Есть несколько способов, со своими плюсами и минусами.

### Способ 1. Префикс

Путям всех API запросов можно выдать значимый префикс, например `/api`. Тогда пути всех запросов примут вид `/api/some/path`. Такой подход не требует тонкой настройки веб-сервера, а так же все API-запросы могут находиться на том же самом домене, что и сайт. Однако, префикс будет дублироваться во всех API-запросах.

Способ является предпочтительным в том случае, если сайт и API реализованы монорепозиторием в одном проекте.

### Способ 2. Домен

API может быть развернуто на специальном домене, отличном от основного домена сайта. Такой способ не внесет в URL-ы дублирующейся информации, но более сложен, чем первый. Он требует:
- Дополнительного домена
- Тонкой настройки веб-сервера (nginx, apache и т.д)
- Разделения сайта и API на отдельные проекты или дополнительной настройки веб-сервера, так как в рамках одного проекта в исходном коде всё равно придется вносить разделение между запросами веб-страниц и API-запросами.

Способ является предпочтительным, если вы планируете создавать сайт и API отдельными проектами, в которых запросы веб-страниц и API-запросы не будут пересекатся.

## Версии API

С развитием сервиса может потребоваться реализовать новую версию API. Чтобы было удобно работать с разными версиями API стоит заранее завести возможность передавать соответствующую информацию в запросы.

Есть много способов, которые имеют свои собственные плюсы и минусы:
- Указывать версию API в пути запроса, например `/api/:version/some/path`.
- Передавать версию API в заголовках запроса.
- и т.д.

Выбирайте тот способ, который вам проще всего реализовать, и который будет удобен для использования клиентам вашего API.

## Единый формат ответа

Для всех API-запросов следует завести единый формат ответа, чтобы клиент мог написать единый обработчик для всех запросов. Это особенно актуально для тех клиентов, которые реализованы на статически-типизируемых языках программирования, например Android-приложения на Kotlin и iOS-приложения на Swift.

Зафиксируйте верхнеуровневый набор полей в ответе от сервера и типы их данных. В рамках ответа на каждый конкретный запрос зафиксируйте тип данных каждого из полей.

Не должно быть подобных случаев:
- При наличии данных в поле выдается массив, а при отсутствии данных в том же поле - пустая строка.
- При наличии данных в поле выдается объект, а при отсутствии данных в том же поле - пустой массив.
- и т.д.

API должно всегда возвращать валидный JSON. Хоть в случае успеха, хоть в случае ошибки. Любой ошибки, даже необработанного исключения. Не должно быть ситуации, что при коде ответа 500 API вернуло HTML-страницу.

Пример единого формата ответа:

```json
{
  "success": true,
  "data": {},
  "errorCode": "",
  "errorMessage": "",
  "errors": {}
}
```

В данном примере приведены следующие поля:
- `success` - `Boolean`. Индикатор успешности выполнения запроса. Если запрос выполнить удалось, имеет значение `true`. Если не удалось - `false`.
- `data` - `Object`. Если запрос выполнился успешно, в данном поле находится объект с информацией, которую запрашивает клиент. Если запрос выполнился неуспешно - имеет значение `null`. 
- `errorCode` - `String`. Если запрос выполнился успешно, содержит значение `null`. Если запрос выполнился неуспешно, содержит код произошедшей ошибки. Это не HTTP-статус, а индикатор конкретной ошибки конкретного запроса. Например, если при аутентификации не удалось найти учетную запись, то кодом ошибки может быть `profile_not_found`.
- `errorMessage` - `String`. Если запрос выполнился успешно, содержит значение `null`. Если запрос выполнился неуспешно, содержит локализованное сообщение для пользователя. В нём не должно быть информации для отладки.
- `errors` - `Object`. Если запрос выполнился успешно, содержит значение `null`. Если запрос выполнился неупешно, может содержать объект с детальной информацией об ошибках. Используется в запросах на создание/редактирование, чтобы сообщить на клиент информацию об ошибках в каждом поле, переданном в запрос.

## Информация об ошибках при создании и обновлении

В запросы на создание и обновление могут передаваться данные с любым уровнем вложенности. Вложенности могут представлять из себя как объекты, так и массивы. Например, запрос обновления информации о профиле может принимать такой JSON:

```json
{
  "profile": {
    "fistName": "Гарри",
    "lastName": "Поттер",
    "address": {
      "country": "Великобритания",
      "city": "Литтл Уингинг",
      "street": "Тисовая улица",
      "house": "4",
      "comments": "Чулан под лестницей"
    },
    "relatives": [
      {
        "firstName": "Джеймс",
        "lastName": "Поттер",
        "role": "father"
      },
      {
        "firstName": "Лили",
        "lastName": "Поттер",
        "role": "mother"
      }
    ]
  }
}
```

В каждом поле на каждом уровне вложенности могут произойти ошибки, о которых нужно сообщить на клиент. С каждым полем может произойти сразу несколько ошибок, например, "Слишком длинное" и "Имеет недопустимые символы". Если того требует дизайн, клиент должен иметь возможность отобразить ошибку около того самого поля, с которым ошибка произошла.

Учитывая описанное выше, можно составить следующую рекурсивную структуру ошибок:

```java
public class ObjectErrors {
  private Map<String, List<String>> fields;
  private Map<String, ObjectErrors> objects;
  private Map<String, List<ArrayObjectErrors>> arrays;
}

public class ArrayObjectErrors extends ObjectErrors {
  private int index;
}
```

Описание полей `ObjectErrors`:

- В `fields` содержатся ошибки по каждому из полей в объекте. Ключ - имя поля. Значение - список ошибок.
- В `objects` содержится информация об ошибках полей во вложенных объектах. Ключ - имя объекта. Значение - информация об ошибках в его полях.
- В `arrays` содержится информация об ошибках полей во вложенных массивах. Ключ - имя массива. Значение - информация об ошибках в его объектах.

Описание полей `ArrayObjectErrors`, наследника от `ObjectErrors`:
- `index` - индекс объекта из переданных параметров. Необходим, чтобы клиент смог определить, с каким именно объектом из массива произошла ошибка.

Для приведенного выше примера ответ с ошибками может выглядеть так:

```json
{
  "success": false,
  "data": null,
  "errorCode": "not_valid",
  "errorMessage": "Переданы некорректные значения",
  "errors": {
    "fields": {
      "firstName": ["Слишком длинное", "Имеет недопустимые символы"],
      "relatives": ["Указано слишком много родителей, максимум 2"]
    },
    "objects": {
      "address": {
        "fields": {
          "country": ["Такой страны не существует"],
          "comments": ["Слишком длинное"]
        },
        "objects": {},
        "arrays": {}
      }
    },
    "arrays": {
      "relatives": [
        {
          "index": 1,
          "fields": {
            "firstName": ["Имеет недопустимые символы"],
            "role": ["Не существует"]
          },
          "objects": {},
          "arrays": {}
        }
      ]
    }
  }
}
```

Информация об ошибках во вложенных объектах и во вложенных массивах разделена на два поля - `objects` и `arrays`, так как в противном случае на статически-типизируемом языке программирования будет невозможно написать универсальный класс для десериализации в него JSON-а. Придется для каждого запроса в отдельности писать свои собственные классы для приёма ошибок.

Обратите внимание, что у вложенного массива ошибка может случиться как по всему массиву в целом (например, слишком много элементов), так и по конкретным объектам в частности. Поэтому упоминание массива может встретиться как в `fields`, так и в `arrays`. То же самое и с объектами. По этой причине введено явное разделение полей объекта на атомарные (`fields`) и структурные (`objects`, `arrays`).

Пример JSON-а с **плохой** структурой ошибок:

```json
{
  "errors": {
    "firstName": ["Ошибка"],
    "relatives": [
      {
        "index": 1,
        "lastName": ["Ошибка"]
      }
    ]
  }
}
```

В данной структуре JSON-а:

1. Невозможно выдать ошибку, относящуюся ко всему массиву `relatives` вцелом, так как ключ `relatives` уже занят массивом объектов.

2. Под ключами `firstName` и `relatives` находятся значения разных типов данных, а набор ключей будет отличаться для других запросов, значит не получится создать универсальный класс для приёма ошибок.

## Коды ответа HTTP

Составьте соответствие кодов ответа HTTP с результатами выполнения запросов.

При успешном выполнении запроса он должен возвращать такой код ответа HTTP, который соответствует успеху. Например, всегда возвращать 200 при успехе.

Составьте соответствие ошибок запросов с кодами ответа HTTP, которые подходят по смыслу к конкретной ошибке. Вот самые популярные из них, которых обычно хватает при создании REST API:

- 400 (Bad Request) - Сервер не понял формат переданных данных. Например, вместо JSON-а был отправлен XML или невалидный JSON.
- 401 (Unauthorized) - Запрос требует авторизации, но не было передано никаких авторизационных данных или по авторизационным данным не удалось идентифицировать клиент.
- 403 (Forbidden) - Удалось идентифицировать клиент, но у него нет прав на выполнение запроса.
- 404 (Not Found) - Не удалось найти запрашиваемые данные. Например, объект с переданным id отсутствует в базе данных.
- 422 (Unprocessable Entity) - Сервер понял тип содержимого, но ему не удалось корректно обработать данные. Например, если клиент передал в поле объекта недопустимые символы.

## Максимально выносить всю возможную логику на бэкенд.

// TODO

## Уменьшить количество запросов для экранов (Например, dashboard с множеством блоков выдавать единым списком)

// TODO

## Универсальность - если можно сделать одинаково, делать одинаково. Например - подборка товаров, это просто фильтрация.

// TODO

## Однакоковые названия одинаковых полей у одинаковых объектов в разных запросах.

// TODO
