# Структура данных для товаров в интернет-магазине

## Введение

Как правило, один и тот же товар в магазине может иметь несколько разновидностей.

Вещи в магазине одежды продаются разных цветов и размеров. Ноутбуки продаются в разных модификациях, которые отличаются размером оперативной памяти, размером SSD, моделью видеокарты и т.д. Назовем эти особенности **опциями**.

Каждая опция имеет свои собственные **значения**. Например, у опции "Цвет" могут быть значения "Красный", "Зеленый", "Синий". У опции "Размер" - значения "S", "M", "L", "XL".

Набор конкретных значений всех опций товара назовём **вариантом** товара. Например, если у товара "Футболка" есть две опции - "Цвет" и "Размер", то его вариантами могут быть "Футболка Красная S", "Футболка Зеленая M" и т.д.

Со временем магазин может начать торговать новыми типами товаров с ранее неизвестными опциями. Например, если в продаже появились штаны, то могут потребоваться опции "Длина" и "Обхват талии".

При разработке интернет-магазина важно спроектировать такие структуру данных и клиент-серверное взаимодействие, чтобы:
- Разные товары могли иметь разный набор опций.
- Появление новых товаров, опций и их значений не приводили к дополнительному программированию.

// TODO Описать свойства товара - данные, которые не зависят от варианта, а лежат в товаре, например "Бренд", "Материал".

## Общие положения

Примеры SQL-кода приведены для базы данных PostgreSQL.

Внешние ключи не описаны, так как это не единственный возможный способ контроля ссылочной целостности, и в некоторых проектах она контроллируется на уровне серверного приложения.

Уникальность так же может контролироваться на уровне серверного приложения, но при параллельной обработке API-запросов может дать сбой. Поэтому, контроль уникальности описан на уровне базы данных.

Все таблицы в описываемой структуре имеют автоинкрементный целочисленный идентификатор, даже если предполагают наличие натурального ключа.

Передача данных между клиентом и сервером описана в формате JSON, а структура данных для сериализации - на языке Java.

## Опции и значения опций

Чтобы иметь возможность добавлять новые опции без программирования, следует завести две таблицы - "Опции" и "Значения опций". Они должны находиться на уровне всего магазина, а не на уровне конкретного товара. Создать опцию и её значения придется единожды, а в рамках товаров оперировать лишь идентификаторами.

Как для опций, так и для их значений, понадобится следующий набор полей:
- Представление. Это название, которое будет показываться в интерфейсе пользователя.
- Системное название, по которому можно идентифицировать опцию или значение на программном уровне. Это полезно в случаях, когда для определенных опций или их значений нужно запрограммировать особый пользовательский интерфейс.

// TODO пример картинки, как выглядит форма с разным отображением полей, где пригодится системное название.

Учитывая требования, можно создать следующие таблицы.

Опции:

```sql
CREATE TABLE options
(
  id bigserial PRIMARY KEY, -- Идентификатор опции
  name character varying, -- Системное название опции, например, "color"
  presentation character varying -- Название опции для пользователя, например, "Цвет"
);
```

Заводить несколько одинаковых опций не имеет смысла, поэтому нужно создать уникальный индекс по полю `name`:

```sql
CREATE UNIQUE INDEX index_options_on_name
  ON options
  (name);
```

Значения опций:

```sql
CREATE TABLE option_values
(
  id bigserial PRIMARY KEY, -- Идентификатор значения опции
  name character varying, -- Системное название значения, например "xl" или "red"
  presentation character varying, -- Название значения для пользователя, например,"XL" или "Красный"
  option_id bigint -- Идентификатор опции, которому принадлежит значение
);
```

Заводить несколько одинаковых значений в рамках одной опции также не имеет смысла, поэтому нужно создать уникальный индекс по двум полям - `option_id`, `name`. Если поставить поле `option_id` на первое место, то индекс будет выполнять сразу две функции:
- Контроль уникальности по двум полям
- Оптимизация выборки значений для конкретных опций

```sql
CREATE UNIQUE INDEX index_option_values_on_option_id_and_name
  ON option_values
  (option_id, name);
```

Структура данных для сериализации в JSON:

```java
public class Option {
  private Long id;
  private String name;
  private String presentation;
  private List<OptionValue> values;
}

public class OptionValue {
  private Long id;
  private String name;
  private String presentation;
}
```

Пример опций:

```json
{
  "options": [
    {
      "id": 1,
      "name": "color",
      "presentation": "Цвет",
      "values": [
        {
          "id": 1,
          "name": "red",
          "presentation": "Красный"
        },
        {
          "id": 2,
          "name": "green",
          "presentation": "Зеленый"
        },
        {
          "id": 3,
          "name": "blue",
          "presentation": "Синий"
        }
      ]
    },
    {
      "id": 2,
      "name": "size",
      "presentation": "Размер",
      "values": [
        {
          "id": 4,
          "name": "s",
          "presentation": "S"
        },
        {
          "id": 5,
          "name": "m",
          "presentation": "M"
        },
        {
          "id": 6,
          "name": "l",
          "presentation": "L"
        },
        {
          "id": 7,
          "name": "xl",
          "presentation": "XL"
        }
      ]
    },
    {
      "id": 3,
      "name": "material",
      "presentation": "Материал",
      "values": [
        {
          "id": 8,
          "name": "cotton",
          "presentation": "Хлопок"
        },
        {
          "id": 9,
          "name": "viscose",
          "presentation": "Вискоза"
        }
      ]
    }
  ]
}
```

Перечисленного набора полей может не хватить из-за специфичной бизнес-логики или пользовательского интерфейса. Например, для цветов понадобится хранить шестнадцатеричный код.

Поля, специфичные для конкретной опции, не нужно добавлять в таблицу значений опций, так как со временем она может превратиться в свалку полей.

Для этих целей заведите специальную таблицу мета-информации для значений опций:

```sql
CREATE TABLE option_value_metas
(
  id bigserial PRIMARY KEY, -- Идентификатор меты
  name character varying, -- Название меты, например, "hex"
  value character varying, -- Значение меты, например, "#ff0000"
  option_value_id bigint -- Идентификатор значения, которому принадлежит мета
);
```

Хранить несколько одинаковых мет для одного значения опций не имеет смысла, поэтому нужно завести уникальный индекс по двум полям - `option_value_id`, `name`. Если поставить поле `option_value_id` на первое место, то индекс будет выполнять сразу две функции:
- Контроль уникальности по двум полям
- Оптимизация выборки мет для конкретных значений опций

```sql
CREATE UNIQUE INDEX index_option_value_metas_on_option_value_id_and_name
  ON option_value_metas
  (option_value_id, name);
```

Структура данных для сериализации в JSON:

```java
public class OptionValue {
  private Long id;
  private String name;
  private String presentation;
  private List<OptionValueMeta> metas;
}

public class OptionValueMeta {
  private Long id;
  private String name;
  private String value;
}
```

Теперь к значениям опций можно прикреплять различную информацию. Например, если для цвета "Красный" нужно добавить шестнадцатиричный код, сохраните в базу данных соответствующую мету:

```json
{
  "id": 1,
  "name": "red",
  "presentation": "Красный",
  "metas": [
    {
      "id": 1,
      "name": "hex",
      "value": "#ff0000"
    }
  ]
}
```

## Товары и варианты

Разные товары могут обладать разным набором опций. Например, опциями футболок могут быть "Цвет" и "Размер", а опциями шкафов - "Ширина", "Высота", "Глубина". Набор конкретных значений опций у товара описывается вариантом товара, например, "Футболка XL Синяя".

Бывают ситуации, когда цена у разных вариантов одного и того же товара отличается.

Не все значения определенной опции могут быть актуальны для определенного товара. Например, в справочнике цветов могут быть цвета "Красный", "Зеленый" и "Синий", а определенная футболка продается только "Красного" и "Зеленого" цветов.

Учитывая описанное выше, можно создать следующий набор таблиц.

Товары:

```sql
CREATE TABLE products (
  id bigserial PRIMARY KEY, -- Идентификатор товара
  name character varying -- Название товара
);
```

Опции, доступные для товара:

```sql
CREATE TABLE product_options (
  id bigserial PRIMARY KEY, -- Идентификатор опции товара
  product_id bigint, -- Идентификатор товара
  option_id bigint -- Идентификатор опции
);
```

Так как у одного товара не должно быть двух одинаковых опций, необходимо создать индекс на уникальность по двум полям - `product_id`, `option_id`. Если поставить поле `product_id` на первое место, то индекс будет выполнять сразу две функции:
- Контроль уникальности по двум полям
- Оптимизация выборки опций для конкретных товаров

```sql
CREATE UNIQUE INDEX index_product_options_on_product_id_and_option_id
  ON product_options
  (product_id, option_id);
```

Варианты:

```sql
CREATE TABLE variants (
  id bigserial PRIMARY KEY, -- Идентификатор варианта
  name character varying, -- Название варианта
  product_id bigint, -- Идентификатор товара, которому принадлежит вариант
  price numeric(8, 2) -- Цена варианта
);
```

Для оптимизации выборки вариантов для конкретных товаров необходимо создать индекс по полю `product_id`:

```sql
CREATE INDEX index_variants_on_product_id
  ON variants
  (product_id);
```

Значения опций конкретного варианта:

```sql
CREATE TABLE variant_option_values (
  id bigserial PRIMARY KEY, -- Идентификатор значения опции в варианте
  variant_id bigint, -- Идентификатор варианта, которому принадлежит значение
  option_value_id bigint -- Идентификатор значения опции
)
```

Так как у одного варианта не должно быть двух одинаковых значений опций, необходимо создать индекс на уникальность по двум полям - `variant_id`, `option_value_id`. Если поставить поле `variant_id` на первое место, то индекс будет выполнять сразу две функции:
- Контроль уникальности по двум полям
- Оптимизация выборки значений опций для конкретных вариантов

Структура данных для сериализации в JSON:

```java
public class Product {
  private Long id;
  private String name;
  private List<Option> options;
  private List<Variant> variants;
}

public class Option {
  private Long id;
  private String name;
  private String presentation;
  private List<OptionValue> values;
}

public class OptionValue {
  private Long id;
  private String name;
  private String presentation;
}

public class Variant {
  private Long id;
  private String name;
  private BigDecimal price;
  private List<Long> optionValueIds;
}
```

Пример выдачи полной информации о товаре и его вариантах в API:

```json
{
  "product": {
    "id": 1,
    "name": "Футболка",
    "options": [
      {
        "id": 1,
        "name": "color",
        "presentation": "Цвет",
        "values": [
          {
            "id": 1,
            "name": "red",
            "presentation": "Красный"
          },
          {
            "id": 2,
            "name": "green",
            "presentation": "Зеленый"
          }
        ]
      },
      {
        "id": 2,
        "name": "size",
        "presentation": "Размер",
        "values": [
          {
            "id": 4,
            "name": "s",
            "presentation": "S"
          },
          {
            "id": 5,
            "name": "m",
            "presentation": "M"
          }
        ]
      }
    ],
    "variants": [
      {
        "id": 1,
        "name": "Футболка S Красная",
        "price": "900.00",
        "optionValueIds": [1, 4]
      },
      {
        "id": 2,
        "name": "Футболка M Красная",
        "price": "950.00",
        "optionValueIds": [1, 5]
      },
      {
        "id": 3,
        "name": "Футболка M Зеленая",
        "price": "950.00",
        "optionValueIds": [2, 5]
      }
    ]
  }
}
```

Как правило, на экране товара отображается список полей, которые пользователь должен заполнить для выбора варианта. По одному полю на каждую опцию. Для программирования такой формы удобно оперировать уникальными наборами опций и их значений, в связи с чем они выданы не внутри вариантов, где могут дублироваться, а отдельно.

// TODO Картинка с примером формы

Если планируется продажа товаров в разных валютах, то имеет смысл завести отдельную таблицу цен на варианты, в которой будет хранится соответствие цены и валюты для каждого варианта:

```sql
CREATE TABLE variant_prices
(
  id bigserial PRIMARY KEY, -- Идентификатор цены на вариант
  amount numeric(8, 2), -- Сумма
  currency_code character varying, -- Код валюты
  variant_id bigint -- Идентификатор варианта, которому принадлежит цена
);
```

Так как у одного варианта не должно быть двух одинаковых валют, необходимо создать индекс на уникальность по двум полям - `variant_id`, `currency`. Если поставить поле `variant_id` на первое место, то индекс будет выполнять сразу две функции:
- Контроль уникальности по двум полям
- Оптимизация выборки цен для конкретных вариантов

```sql
CREATE UNIQUE INDEX index_variant_prices_on_variant_id_and_currency_code
  ON variant_prices
  (variant_id, currency_code);
```

Структура данных для сериализации в JSON:

```java
public class Variant {
  private Long id;
  private String name;
  private List<Long> optionValueIds;
  private List<VariantPrice> prices;
}

public class VariantPrice {
  private Long id;
  private BigDecimal amount;
  private String currencyCode;
}
```

Пример выдачи вариантов со списком цен в API:

```json
{
  "variants": [
    {
      "id": 1,
      "name": "Футболка S Красная",
      "optionValueIds": [1, 4],
      "prices": [
        {
          "id": 1,
          "amount": "900.0",
          "currencyCode": "RUB"
        },
        {
          "id": 2,
          "amount": "11.5",
          "currencyCode": "USD"
        }
      ]
    }
  ]
}
```

## Корзина

Клиент покупает конкретные варианты товаров с указанием количеств, что определяет минимальную структуру для хранения информации о товарах в корзине.

Корзину можно рассматривать как частный случай заказа, который находится в определенном статусе и содержит одну или более позиций. В таком случае, не придётся создавать дополнительные таблицы для хранения корзины и информации о товарах в ней.

В связи с вышеперечисленным можно создать следующую структуру таблиц.

Заказы:


```sql
CREATE TABLE orders (
  id bigserial PRIMARY KEY, -- Идентификатор заказа
  status integer -- Статус заказа
)
```

Позиции заказа:

```sql
CREATE TABLE order_items (
  id bigserial PRIMARY KEY, -- Идентификатор позиции заказа
  order_id bigint, -- Идентификатор заказа, которому принадлежит позиция
  variant_id bigint, -- Идентификатор варианта в позиции заказа
  count integer -- Количество вариантов товара
)
```

Структура данных для сериализации в JSON:

```java
public class Order {
  private Long id;
  private OrderStatus status;
  private List<OrderItem> items;
}

public enum OrderStatus {
  CART(0, "cart");

  private final int value;
  private final String name;

  OrderStatus(int value, String name) {
    this.value = value;
    this.name = name;
  }
}

public class OrderItem {
  private Long id;
  private Variant variant;
  private Integer count;
}

public class Variant {
  private Long id;
  private String name;
  private BigDecimal price;
  private Long productId;
  private List<OptionValue> optionValues;
}

public class OptionValue {
  private Long id;
  private String name;
  private String presentation;
  private Option option;
}

public class Option {
  private Long id;
  private String name;
  private String presentation;
}
```

Пример выдачи корзины в API:

```json
{
  "cart": {
    "id": 1,
    "status": "cart",
    "items": [
      {
        "id": 1,
        "count": 2,
        "variant": {
          "id": 1,
          "name": "Футболка S Красная",
          "price": "900.0",
          "productId": 1,
          "optionValues": [
            {
              "id": 1,
              "name": "red",
              "presentation": "Красный",
              "option": {
                "id": 1,
                "name": "color",
                "presentation": "Цвет"
              }
            },
            {
              "id": 4,
              "name": "s",
              "presentation": "S",
              "option": {
                "id": 2,
                "name": "size",
                "presentation": "Размер"
              }
            }
          ]
        }
      }
    ]
  }
}
```

Как правило, на экране корзины нет логики для смены варианта, а необходимо лишь отобразить значения опций, поэтому они выгружены напрямую в вариантах.

## Товары без опций

Магазин может торговать товарами без опций, у которых не будет разных вариантов. Например, стульями, у которых нет доступных для выбора характеристик - ни разных цветов, ни разных размеров. Просто стул. Такая концепция конфликтует с идеей, что в корзину добавляется вариант, а не товар.

Для таких товаров все равно необходимо создать вариант в базе данных, один единственный, без значений опций. В нём будут храниться данные, которых не хватает в таблице товаров. Такой вариант пригодится и для тех товаров, у которых есть опции. Назовём его **главным вариантом**. В базе данных необходимо завести для него соответствующий индикатор:

```sql
ALTER TABLE variants
ADD COLUMN is_main boolean;
```

Главный вариант должен присутствовать у любого товара. Если у товара нет опций, то в корзину добавляется главный вариант. Если у товара есть опции, то в корзину добавляется конкретный вариант, а главный вариант используется для следующих целей:
- Как шаблон для создания новых вариантов, из которого можно брать значения для предзаполнения полей. Например, в панели управления администратора при создании нового варианта.
- Как набор значений по умолчанию для пользовательского интерфейса, где еще не выбран конкретный вариант товара. Например, при отображении цены в списке товаров.

Таким образом, структуру товара в API можно расширить, выдав главный вариант параллельно с остальными.

```java
public class Product {
  private Long id;
  private String name;
  private List<Option> options;
  private Variant mainVariant;
  private List<Variant> variants;
}
```

## Дальнейшие доработки

В ходе разработки может оказаться, что описанной выше структуры данных не достаточно для определенных задач. Например, понадобится отображать для товаров текстовые описания или изображения.

Перед тем, как доработать структуру, подумайте, может ли эта информация отличаться между разными вариантами одного товара. Например, для разных цветов товара можно показывать разные изображения.

Если для разных вариантов могут понадобиться разные значения, расширяйте таблицу вариантов.

// TODO добавить прототипы товаров

// TODO добавить фильтрацию каталога (формат передачи фильтров между клиентом и сервером, оптимизированные SQL-запросы)

// TODO - привести примеры URL-ов для API-запросов?
